#분할정복 (Divied-and-Conquer)

---

##1. 이분검색
>분할-정복-취합,
이를 재귀적으로 분할하여 지속적으로 실행함

꼬리 재귀 (tail-recursion)

##2. 합병정렬 (two-way merging)
배열을 계속 반씩 나누어가면서 순서대로 배열하는 정렬방법

제자리정렬(in-place sort)

##4. 빠른정렬(분할교환정렬)

빠른정렬(QuickSort)
기준원소(pivot)를 설정하여 기준원소 보다 작으면 왼쪽, 크면 오른쪽으로 보내준다.
입력값으로 양의 정수 n, 배열 S

일정복잡도 계산이 불가능하다. 따라서 최악의 경우, 평균의 경우만 구한다.

- 최악의 경우: 완전히 정렬된 배열을 정렬하는 경우
T(n) = T(0) + T(n-1) + n-1, n>0, T(0) = 0

T(n) = n*(n-1)/2

- 평균의 경우 : ln n (합병정렬ㄹ의 시간복잡도와 같다.)

##5. Strassen의 행렬곱셈 알고리즘

2*2 행렬 이상에서 효과적으로 돋보인다.

<b>예제 2.5를 참고할것</b>

임계점 (threshold)은 strasse procedure를 재귀호출 하는 것 보다 표준 아록리즘을 사용하는 것이 효율적인 시점이다.

<b>Strassen의 곱셈 수의 일정 시간복잡도 분석</b>

T(n) = m^(lg7)

<b>Strassen의 덧셈/뺄셈 수의 일정 시간복잡도 분석</b>

T(n) = 6n^lg7 - 6*n^2

표준 알고리즘과 비교시 임계점을 넘어가면 효과가 없어진다. 따라서 Strassen 알고리즘은 효율적이라 보기 어렵다.

##6. 큰 정수 계산법

###6.1 큰 정수표현 : 덧셈과 기타 1차시간 연산
large_integer로 표현

###6.2 큰 정수 곱셈

n개 자리수의 곱셈을 n/2의 자리수로 나누어 연산한다.

곱하고자 하는 두 숫자의 자리수가 달라도 연산이 가능하다.

큰 정수 곱셈의 최악 시간복잡도 분석

##7. 임계값의 결정

